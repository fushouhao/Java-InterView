Java 面试
====

一.java基础知识
##
### ***1.面向对象***
以对象作为基本单位 用类作为模板来描述他的属性和行为 一共有三个特性 继承 封装和多态
#####
 1.继承 java中的类只能单继承 一个子类只能有一个父类 一个父类能有多个子类 接口不属于继承范畴 一个类可以实现多个接口
#####
 2.封装 通过封装类的某些属性 来保护这些属性 让其他人想修改其中属性时只能通过set/get方法 我们通过定义 这两个方法来控制该属性的访问权限
#####
 3.多态 主要有三种表现形式 方法重载 重写（编译时多态） 向上转型 （运行时多态）

### ***2.JDK JRE JVM***
###
1.JDK Java开发工具包 包含运行环境的JRE java的基础类库 java的一些工具包
###
2.JRE JAVA程序的运行环境 所有的程序必须依赖jre才能运行
###
3.JVM jre的一部分 只关心 Java源程序编译出的字节码文件 jvm是程序实现跨平台的核心 

***3.==和equals***
==是运算符 如果是基本数据类型 则会比较数据存储的值 如果是引用类型 则比较地址值
###
equals是Object方法 比较的是对象的地址值 一般会重写 比如String类
（源码需要分析）

### ***4.String***
String s = new String ("abc")
###
一共创建了两个对象 "abc" 和 new String 存在两层引用关系
###
String 底层是char数组 可以直接赋值字符串
###
String Buffer,String builder必须通过new对象的形式装值
###
String 底层是char数组 可以直接赋值字符串
###
String 拼接直接通过+，并且拼接操作是生成了新的字符串，原有的字符串还在。
###
String Buffer,String builder必须通过append，不会产生新的字符串，优势在于不会额外占据新的内存空间 节约内存
###
String Buffer 线程安全 执行效率低 底层是以synchronized锁修饰
###
String builder 线程不安全 执行效率高

### ***4.接口和抽象类***
###
(1). 结构不同：
###
接口四大结构：常量、抽象方法、静态方法、默认方法
###
抽象类六大结构：成员变量、方法、构造方法、代码块、内部类、抽象方法
###
(2). 实现形式不同：
###
接口：被实现类多实现，并重写抽象方法实现具体功能(功能扩展性更强)
###
抽象类：被子类单继承，并重写抽象方法实现具体功能


###
 (3). 代码简化形式不同：
###
接口：接口中的结构可以适当的进行简化编写
###
抽象类：抽象类中的结构不可以简化编写
###
### ***5.ArrayList和LinkedList区别***
###
1.ArrayList的底层是数组 LinkedList底层是双端链式结构 对头部和尾部都可以操作
###
2.ArrayList 向集合中间插入或删除数据时效率比较低 查询效率比较高（因为数组是一块连续的空间 程序先找到数组的首地址 然后根据下标算出该下标元素在内存中的位置 所以不需要一个个去遍历）
###
LinkedList 向集合中间插入或者删除数据时效率比较高（只需要将上一个元素的指针指向下一个元素即可） 查询的效率比较低（由于链表中的元素不是连续存储的 要想访问链表的某个元素 需要从头节点依次遍历）
### ***6.List和Set的区别***
###
1.List集合：数据可重复存储，数据有序(可利用索引操作数据)(Collection接口的子接口)
###
2.Set集合：数据不可重复存储，数据无序(Collection接口的子接口)
### ***7.HashMap和HashTabe的区别***
###
1.从功能角度来说
###
1.HashTable线程安全（采用全局锁）性能稍差  HashMap线程不安全 性能好
###
2.从内部实现角度来说
###
HashTable 使用数组加链表、HashMap 采用了数组+链表+红黑树
###
HashMap 初始容量是 16、HashTable 初始容量是 11
###
HashMap 可以使用 null 作为 key，HashMap 会把 null 转化为 0 进行存储，而 Hashtable 不允许
###
最后，他们两个的 key 的散列算法不同，HashTable 直接是使用 key 的 hashcode 对数组长度做取模
###
而 HashMap 对 key 的 hashcode 做了二次散列，从而避免 key 的分布不均匀问题影响到查询性能
###
### ***8.concurrentHashMap的整体架构***
1.由数组 链表 红黑树组成
###
2.初始化实例时 会初始话一个默认长度为16的数组 
###
3.采用链式寻址法来解决hash冲突
###
4.冲突比较多的时候造成链表长度较长 最后变成O(n)
###
5.当数组长度大于64并且链表长度大于等于8的时候 就会转换为红黑树
###
6.但是如果动态扩容之后链表长度小于8红黑树会退化成单向链表
###
7.功能和hashmap一样 在基础上提供了并发安全的实现（对指定的node节点加锁）
###
8. jdk1.8 锁的粒度是一个节点 而1.7版本是锁一个范围segment 性能上更低
###
9.引入红黑树之后 数据查询的时间复杂度变成了O（logn）
###
10.数组长度不够时（什么时候数组长度会不够？） 需要扩容，concurrentHashMap引入了多线程并发扩容机制，多个线程对原始数组进行分片后，每个线程负责一个分片的数据迁移，从而提升了扩容过程数据迁移的效率
###
11.在多线程并发场景中 保证原子性的前提下实现元素个数的增加 性能是非常低的
优化 ： 线程竞争不激烈时 直接采用CAS来实现元素个数的原子递增  线程竞争激烈时 使用一个数组来维护元素个数，如果要增加总的元素个数，则直接从数组中随机选择一个 再通过CAS实现原子递增
### ***9.CAS***
###
1.java中unsafe类里面的方法 全称是CompareAndSwap 比较并变换
###
2.  多个线程同时对一个数进行修改 就会出现原子性的问题（多个插入和删除同时进行就有可能丢失数据）
###
3.加同步锁可能会带来性能上的损耗
调用compareAndSwapInt()方法 比较内存地址偏移量对应的值和传入的预期值是否相等 如果相等 则直接修改内存中的值 否则返回false
###
4.但是这种情况仍然会出现原子性问题 先取值 再比较 最后修改
###
5.所以在底层 会增加Lock指令对缓存或总线加锁 保证原子性






